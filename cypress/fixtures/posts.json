[{"id":"how-to-code-review","subheadings":["TL;DR","Introduction","Check that the code can be built and deployed","Scope and intent","Make sure the code fulfills the intent","Ensure all comments relate to the main points of focus.","Spellcheck your comments and remove unnecessary information.","Have discussions in person or via a call and only write down the summary","Let the author know if they can merge the code.","Conclusion"],"content":"\n# How to code review\n\n![Two people having a discussion in front of laptops in a conference room](https://images.unsplash.com/photo-1553877522-43269d4ea984?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80)\n\n## TL;DR\n\nI'm a developer, of course, I wrote a checklist:\n\n- Check that the code can be built and deployed.\n- Define the scope and intent of the code you are reviewing.\n- Check the code fulfills the intent\n- Ensure all comments and discussions are related to maintainability, performance, or functionality.\n- Spell check your comments and remove unnecessary information.\n- Have discussions in person or via a call and only write down the summary\n- Let the author know if they can merge the code.\n\n## Introduction\n\nAll companies and organizations that I worked for recognize the value of peer reviews. They praise it in company-wide all-hands meetings. They make it an obligatory part of the software development process. They encourage everyone to give candid feedback as often as possible.\n\nAnd yet, none of them have added peer review training to their onboarding process. None of the interviews I had included specific questions about code reviews. None of them have guidelines on what separates a good, useful code review from a bad one. Their managers and team leaders do not lead by example. They do not set the norm by defining a context of what is and what is not allowed.\n\nAll have employees that oppose (sometimes very vocally) doing code reviews. All have employees that see code reviews as something imposed onto them. Something that they would rather not do. Something that they can do poorly. There is a clear divide between an abstract concept we all know is good and putting it into practice.\n\nThis post focuses on being pragmatic. What to do, what not to do, and how to get the biggest benefit from peer reviews. The points I make can serve as a foundation for putting code reviews into practice. They can serve as a base for comparison of how well your team is currently doing. They are not a be-all-end-all solution. When working in a team we should adjust to the team’s specific needs and personalities. We should be mindful of the context of our specific situation. Nevertheless, this is a good place to start and improve upon.\n\n## Check that the code can be built and deployed\n\nMost projects have an automated process in place for doing this. In the JavaScript world, CI linting, tests, and builds are common. That being said some projects might not have these fail-safes. The failsafe might fail. They might not block opening the merge request. The author might have missed the automatic message about a failing build.\n\nAlways check if the code can be built and deployed as-is. If the build or another part of the deployment process will fail there is no point in doing a review. The code will need to change and be reviewed again before being merged.\n\n## Scope and intent\n\nBefore reading the code you should define the scope and intent of the proposed changes. This was already done by the colleague writing the code before you but needs a revision. They might not have documented it. They might have missed an important detail. They might have misinterpreted what the code should do. Without understanding the scope and intent you do not have a yardstick to measure the code against.\n\nIf you are having trouble doing this, these are some good questions to ask. You can try to answer these yourself, but after you do, always check that the author of the code agrees with you.\n\n- What should change for the user of the software?\n- What should change for the person making the software?\n- How much value does this change bring to the company?\n\nThese should help define how important the three main points of focus for the code review are. Maintainability, performance, and functionality. It might bring another point of focus and it might mean that one of the main points is irrelevant. People don't value maintainability and performance when a production bug is losing the company large amounts of money. People value maintainability when adding new core features to the system. Think about considerations like these before starting to review the work.\n\n## Make sure the code fulfills the intent\n\nThis is what I see skipped the most when in a hurry or tired. Surely the person that wrote the code checked what it does? Trust me there is no stupider feeling than not running the code and approving it, then deploying a bug. It makes you frustrated with the author of the code. He was supposed to do better. It makes the author frustrated with you. You were supposed to be the failsafe he can depend on.\n\nAs with the build and deploy step, commenting on the code that does not fulfill its intent is irrelevant. The code will need to be changed and reviewed again afterward. Check if everything works as expected and if not, let the author know what is wrong without looking at the code.\n\n## Ensure all comments relate to the main points of focus.\n\nSo we finally got to the part where you get to read the code. When reviewing the code keep the main points of the review in mind. How important is the maintainability of the code? How important is the functionality? How important is the performance? Is there anything else that is equally or more important? Always try to communicate to the reader what your comments and suggestions relate to. Constructive criticism is received much better when it means achieving a common goal.\n\nAfter you are done with reading and commenting on the code review your comments. Pause if you need to refresh for a bit. Try to read the comments from the perspective of the person receiving the feedback. Is it easy to understand what you are trying to say? Are the comments relevant? Are they concise and to the point? Can they be perceived as overly emotional or critical? Is there any information missing? Is all the information in the comment relevant?\n\n## Spellcheck your comments and remove unnecessary information.\n\nLet me start by quoting a popular Twitch streamer that I enjoy watching. \"If you are not able to right-click the squiggly word and choose the correct spelling you are not very smart. Then why would I value your opinion?\". You should ensure that all your comments are spelled and worded correctly. You should check that all the information in the comment is relevant. If something is not relevant to the point you are making remove it from the comment.\n\nThis shows your colleagues that you value their time. Everybody hates getting back a code review that is blocking a merge. Don't make your colleagues waste time by trying to guess what word you miss-spelled. Don't make your colleagues read additional information that they do not need to.\n\n## Have discussions in person or via a call and only write down the summary\n\nIt is not uncommon that a comment or a suggestion will reveal a lack of understanding. People will often disagree with your opinion. They will want a chance to explain their decisions. These discussions can go long and drag out through the day. Sometimes reaching a decision can take days. Written text is also subject to different emotional interpretations. You do not get any real-time feedback if the person you are talking to understands you. You cannot give the same feedback back.\n\nI find that in cases where a discussion is needed, this is usually best done in person or via a video call. It speeds up the process of getting everyone on the same page considerably. It gives everyone a chance to be able to stop the other person and say \"Stop, I don't understand what you are saying. Please elaborate a bit”. After the discussion, a summary needs to be written under the code review comment. It should document which decision was made and why. More than one person might review the code. You might come back to the code after some time and check why something was added. The explanation should be there.\n\n## Let the author know if they can merge the code.\n\nAfter you are satisfied with your comments, you should let the author know if they can merge the code or not. This is the only part of the code review that I feel the team (or the company) should have a clear guideline for. The person that requested the code review should know if the code can be deployed or not. While this might seem obvious when seen written down a lot of edge cases happen when things are not clear. It will happen that a suggestion or a comment will be good but out of scope. In that case, after it was written down for further improvements the code can be merged. It will happen that you will want to point out that a bad practice harms maintainability. It will happen that you will point out that something harms code performance. Some of these comments will not be implemented but have learning value. It should be clear after the review which comments (if any) need to be addressed before merging the code.\n\n## Conclusion\n\nI believe peer reviews are very valuable. They help with building trust and respect between colleagues. They are a natural way for knowledge sharing to happen. They are a very good way to normalize giving candid feedback often. This post is not meant to be a rant about everything that people do wrong. It is meant to give a strong foundation for people that have not done code reviews before. It is meant to make people that do code reviews think and discuss their approaches. Finally, it is also meant as a reminder to myself that taking the time needed for a proper code review is important. Thanks for reading until the end and I hope it helps.\n","data":{"categories":"Software development","date":"2022-02-02","description":"Things to do before starting a code review, best practices on how to do a code review, and things to be mindful of. What to check before submitting your code review. How to avoid long discussions and conflict when doing peer revies.","imageUrl":"https://images.unsplash.com/photo-1553877522-43269d4ea984?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80","title":"How to code review"},"isEmpty":false,"excerpt":""},{"id":"react-conditional-rendering","subheadings":["TL;DR","Introduction","Multiple conditions","Intrinsic cognitive load","The hidden cost of software requirements","Don't repeat yourself","Error reporting, debugging, and testing","Conclusion"],"content":"\n# Clean-er ReactJS Code - Conditional Rendering\n\n![A lot of spaghetti](https://images.unsplash.com/photo-1559394452-087c19c260ac?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1176&q=80)\n\n## TL;DR\n\nMove render conditions into appropriately named variables. Abstract the condition logic into a function. This makes the render function code a lot easier to understand, refactor, reuse, test, and think about.\n\n## Introduction\n\nConditional rendering is when a logical operator determines what will be rendered. The following code is from the examples in the official ReactJS documentation. It is one of the simplest examples of conditional rendering that I can think of.\n\n```javascript\nfunction Mailbox(props) {\n  const unreadMessages = props.unreadMessages;\n  return (\n    <div>\n      <h1>Hello!</h1>\n      {unreadMessages.length > 0 && (\n        <h2>You have {unreadMessages.length} unread messages.</h2>\n      )}\n    </div>\n  );\n}\n\nconst messages = [\"React\", \"Re: React\", \"Re:Re: React\"];\nReactDOM.render(\n  <Mailbox unreadMessages={messages} />,\n  document.getElementById(\"root\")\n);\n```\n\nI believe it would be better to write this as a function outside the scope of the Component. This improves code readability and code reusability. It also makes the code easier to test and optimize. But the biggest benefit this provides is lessening the cognitive load of programmers.\n\n## Multiple conditions\n\nThis is an example of conditional rendering that I come across often. Instead of a single condition, we now have many conditions inside the render function.\n\n```javascript\nconst OptionsPanel = ({ user }) => {\n  const { role } = user;\n\n  return (\n    <>\n      {role !== 29 && role !== 21 && role !== 11 && role !== 30 ? (\n        <div>Admin options panel placeholder</div>\n      ) : (\n        <div>User options panel placeholder</div>\n      )}\n    </>\n  );\n};\n\nReactDOM.render(\n  <OptionsPanel user={{ role: 5 }} />,\n  document.getElementById(\"root\")\n);\n```\n\nIf the user role is 29, 21, 11 or 30 we return the `AdminOptionsPanel` Component. If the user role is anything else we return the `UserOptionsPanel`. These are the main issues I have with the approach:\n\n- The business logic is paired with the render logic. This makes it harder to think about the render logic in isolation.\n- The business logic is not communicated at all. Without knowing what roles 29, 21, 11, and 30 stand for the reader does not know why this decision is made.\n- The condition is not exportable. We need to repeat it if we have the same render condition for different elements inside our codebase.\n- The condition is hard to test in isolation. Render functions are seldom this simple. Testing the final output of the Component will not determine if the render condition is causing issues.\n\n## Intrinsic cognitive load\n\nThis is the inherent level of difficulty associated with a specific instructional topic. The more complex the instructions, the more mental effort is needed to understand them. 4 + 9 is easier to understand and reason about than a complex mathematical equation. In our code example, we are mixing two different types of information at the same time. We are relying on the reader to know what certain roles mean. Without that he is unable to know the intent behind our Component. Let's refactor the code to address this first.\n\n```javascript\nconst OptionsPanel = ({ user }) => {\n  const { role } = user;\n\n  const displayAdminOptionsPanel = React.useMemo(\n    () => role !== 29 && role !== 21 && role !== 11 && role !== 30,\n    [role]\n  );\n\n  return (\n    <>\n      {displayAdminOptionsPanel ? (\n        <div>Admin options panel</div>\n      ) : (\n        <div>User options panel</div>\n      )}\n    </>\n  );\n};\n```\n\nIt may not seem like much, but now we have split our logic into two thought processes. We can think about one without the other. When checking if the render function works we need to check the ternary condition and markup. The same goes for the `displayAdminOptionsPanel` constant. We need to concern ourselves with how the content of the variable (true/false in our case) is set. The intrinsic cognitive load of the person that is trying to understand our code is a lot smaller. As a nice bonus, we are also able to wrap our variable inside Reacts `useMemo` hook.\n\nI can already hear the grumbling about useless nitpicking. The effort that goes into this would be better spent writing more code, right? The thing about this is that decisions like these matter. They will impact your performance in invisible ways. Constant dropping wears away a stone. We are reading a high amount of functions like these every day. The intrinsic cognitive load matters. The time we spend trying to understand code already written could be spent writing new code.\n\n## The hidden cost of software requirements\n\nDevelopers are almost never lucky enough to get very specific instructions. Our customers do not say \"user role 22 should have access to the admin options panel\". Instead the bug report or feature request is phrased from their perspective. The business perspective. We will hear \"Project managers should also be able to access the admin options\". Or rather \"Joe from project management cannot access options\". It is our job to know that Joe from project management has user role 22, and where the issue in the code is coming from. With this in mind let's try to refactor our previous code to make the business logic clearer.\n\n```javascript\nconst ALL_USER_ROLES = [\n  29, // admin\n  21, // sales\n  11, // project management\n  30, // marketing\n  5, // customer\n  10, // intern\n];\n\nconst ADMIN_ROLES = [29, 21, 11, 30];\n\nconst hasAdminPermissions = (userRole) => ADMIN_ROLES.includes(userRole);\n\nconst OptionsPanel = ({ user }) => {\n  const { role } = user;\n\n  const displayAdminOptionsPanel = React.useMemo(\n    () => hasAdminPermissions(role)[(hasAdminPermissions, role)]\n  );\n\n  return (\n    <>\n      {displayAdminOptionsPanel ? (\n        <div>Admin options panel</div>\n      ) : (\n        <div>User options panel</div>\n      )}\n    </>\n  );\n};\n```\n\nWe have documented every known user role and admin role in our system. We have abstracted checking if a user has admin permissions into a separate function. We have further reduced the intrinsic cognitive load of our reader. It is now clear what the initial software requirements were. The admin options panel should only be available for users with admin permissions. We can now check our four points of failure in isolation:\n\n- Are the roles defined correctly?\n- Is the function that checks the user roles working as expected?\n- Is the component passing the user role to the function?\n- Is the render ternary condition correct?\n\nThe reader no longer has to know why only certain roles are able to use the admin options panel. The code provides this information. This also simplifies communication between coworkers by making questions more specific. It also makes certain question (why does the code work this way type of questions) unnecessary.\n\n## Don't repeat yourself\n\nThere is another benefit to moving the business logic into a separate function. Business logic is often repeated. If we follow our example, users with admin permissions might be able to see other parts of the interface. They might be able to access certain confidential data. They might be able to edit certain information. In that case, having a reusable function for checking user role permissions is very handy. It provides a single point of failure and debugging for the whole codebase. Once we validated it works as specified it will work that way everywhere. We no longer have to do a global search for this condition to add an admin role or to remove an existing one. These are all great benefits that improve productivity and confidence in our codebase.\n\n## Error reporting, debugging, and testing\n\nStructuring our code this way gives us better error reporting. We now see which specific function failed and can fix it in isolation. Debugging our code is easier since we can focus on a much smaller scope at a time. Finally, testing our code can be a lot more specific. While we could only test what our component rendered before, we can now check every single step:\n\n- Did the roles come from the correct constant?\n- Did the function check the user role permissions?\n- Did the Component call the permissions check, passing the right argument?\n- Did the render return the correct markup?\n\nThis gives us a lot more confidence when refactoring or adding more functionality.\n\n## Conclusion\n\nWriting logic unrelated to markup in separate functions has a lot of added benefits:\n\n- Reducing the cognitive load, enabling us to do more.\n- Business logic is separated and easier to understand.\n- Our code is reusable and provides a single source of truth.\n- Error reporting is more specific.\n- Testing is more specific and gives faster and better feedback.\n\nAll this results in fixing bugs, refactoring and adding features being easier. That being said, this is not a silver bullet that will work everywhere. Sometimes structuring your code in this way is more effort than it is worth. After reading this post, you are able to decide whether the benefits for your team are worth the effort this approach requires.\n","data":{"categories":"ReactJS;Clean Code","date":"2022-01-07","description":"How to write cleaner, extendable and testable ReactJS component render functions.","imageUrl":"https://images.unsplash.com/photo-1559394452-087c19c260ac?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1176&q=80","title":"Clean-er ReactJS Code - Conditional Rendering"},"isEmpty":false,"excerpt":""}]