[{"id":"how-to-code-review","subheadings":["TL;DR","Introduction","Check that the code can be built and deployed","Scope and intent","Make sure the code fulfills the intent","Ensure all comments relate to the main points of focus.","Spellcheck your comments and remove unnecessary information.","Have discussions in person or over a call, and only write down the summary","Let the author know if they can merge the code","Conclusion"],"content":"\n# How to code review\n\n![A person taking notes on a piece of paper between two laptop screens](https://images.unsplash.com/photo-1454165804606-c3d57bc86b40?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80)\n\n## TL;DR\n\nI'm a developer, so of course I wrote a checklist:\n\n- Check that the code can be built and deployed.\n- Define the scope and intent of the code you are reviewing.\n- Check that the code fulfils the intent\n- Ensure all comments and discussions are related to maintainability, performance, or functionality.\n- Spell check your comments and remove any unnecessary information.\n- Have discussions in person or over a call, and only write down the summary\n- Let the author know if they can merge the code.\n\n## Introduction\n\nAll companies and organisations that I’ve worked for recognise the value of peer reviews. They praise it in company-wide all-hands meetings. They make it an obligatory part of the software development process. They encourage everyone to give candid feedback as often as possible.\n\nAnd yet, none of them have added peer review training to their onboarding process. None of the interviews I’ve had have included specific questions about code reviews. None of these companies have provided guidelines on what separates a good, useful code review from a bad one. Their managers and team leaders do not lead by example. They do not set the norm by defining a context of what is and what is not allowed.\n\nAll have employees that oppose (sometimes very vocally) doing code reviews. All have employees that see code reviews as something imposed on them - something that they would rather not do, and something that they can do half-heartedly. There is a clear divide between an abstract concept we all know is good and the process of actually putting it into practice.\n\nThis post focuses on being pragmatic; what to do, what not to do, and how to get the biggest benefit from peer reviews. The points I make can serve as a foundation for putting code reviews into practice, and can serve as a base for comparison of how well your team is currently doing. They are not a be-all-end-all solution. When working in a team, we should adjust to the team’s specific needs and personalities, and be mindful of the context of our specific situation. Nevertheless, this is a good place to start and improve upon.\n\n## Check that the code can be built and deployed\n\nMost projects have an automated process in place for doing this. In the JavaScript world, CI linting, tests and builds are common. That being said, some projects might not have these fail-safes. The fail-safe might fail, they might not block the merge request from opening, or the author might have missed the automatic message about a failing build.\n\nAlways check if the code can be built and deployed as is. If the build or another part of the deployment process fails, there is no point in doing a review. The code will need to be changed and reviewed again before being merged.\n\n## Scope and intent\n\nBefore reading the code, you should define the scope and intent of the proposed changes. This was already done by the colleague writing the code before you, but it most likely needs a revision. They might not have documented it, they might have missed an important detail, or they might even have misinterpreted what the code should do. Without understanding the scope and intent, you do not have a yardstick against which to measure the code.\n\nIf you’re having trouble doing this, here are some good questions to ask. You can try to answer these yourself, but after you do, always check that the author of the code agrees with you.\n\n- What should change for the user of the software?\n- What should change for the person making the software?\n- How much value does this change bring to the company?\n\nThese questions should help to define how important the three main points of focus for the code review - maintainability, performance, and functionality - are. It might bring another point of focus, and it might even mean that one of the main points is irrelevant. People don't value maintainability and performance when a production bug is costing the company large amounts of money. People value maintainability when adding new core features to the system. Think about considerations like these before starting to review the work.\n\n## Make sure the code fulfills the intent\n\nThis is what I see skipped the most when developers are tired or in a hurry. Surely the person that wrote the code checked what it does? Trust me, there is no feeling more stupid than not running the code and approving it, only to deploy a bug. You get frustrated with the author of the code. They should’ve done better. The author gets frustrated with you. You were supposed to be the fail-safe they could depend on.\n\nAs with the build and deploy step, commenting on the code that does not fulfil its intent is irrelevant. The code will need to be changed and reviewed again afterwards. Check if everything works as expected, and if not, let the author know what is wrong without looking at the code.\n\n## Ensure all comments relate to the main points of focus.\n\nSo we’ve finally got to the part where you get to read the code. When reviewing the code, keep the main points of the review in mind. How important is the maintainability of the code? How important is the functionality? How important is the performance? Is there anything else that is equally important, or perhaps even more so? Always try to communicate to the reader what your comments and suggestions relate to. Constructive criticism is received much better when it means achieving a common goal.\n\nAfter you are finished reading and commenting on the code, review your comments. Pause if you need to refresh for a bit. Try to read the comments from the perspective of the person receiving the feedback. Is it easy to understand what you are trying to say? Are the comments relevant? Are they concise and to the point? Can they be perceived as overly emotional or critical? Is there any information missing? Is all the information in the comment relevant?\n\n## Spellcheck your comments and remove unnecessary information.\n\nLet me start by quoting a popular Twitch streamer that I enjoy watching. \"If you are not able to right-click the squiggly word and choose the correct spelling, you are not very smart. Why would I value your opinion?\". You should ensure that all your comments are spelled and worded correctly. You should check that all the information in the comment is relevant. If something is not relevant to the point you are making, remove it from the comment.\n\nThis shows your colleagues that you value their time. Everybody hates getting back a code review that is blocking a merge. Don't waste your colleagues’ time by making them guess which word you misspelled. Don't make your colleagues read additional information that they do not need to know.\n\n## Have discussions in person or over a call, and only write down the summary\n\nt is not uncommon for a comment or suggestion to reveal a lack of understanding. People will often disagree with your opinion. They will want a chance to explain their decisions. These discussions can become long and dragged out, and sometimes reaching a decision can take days. Written text is also subject to different emotional interpretations - you do not get any real-time feedback as to whether the person you are talking to understands you, and you cannot return such feedback either.\n\nI find that in cases in which a discussion is needed, this is usually best done in person or through a video call. It speeds up the process considerably, allowing everyone to be on the same page. It gives everyone a chance to be able to stop the other person and say, \"Stop, I don't understand what you mean. Please elaborate a bit”. After the discussion, a summary needs to be written under the code review comment. It should document which decision was made and why. More than one person might review the code, or you might want to come back to the code after a while and check why something was added. The explanation should be plain to see.\n\n## Let the author know if they can merge the code\n\nAfter you are satisfied with your comments, you should let the author know if they can merge the code or not. This is the only part of the code review that I feel the team (or the company) should have clear guidelines for. The person that requested the code review should know if the code can be deployed or not. While this might seem obvious when written down, a lot of edge cases happen when things are not clear. It will occur that a suggestion or comment will be good but out of scope. In that case, after it is written down for further improvements, the code can be merged. It is also likely that you will want to point out a bad practice that harms maintainability, or something that affects code performance. Some of these comments will not be implemented, but they nonetheless have learning value. It should be clear after the review which comments (if any) need to be addressed before merging the code.\n\n## Conclusion\n\nI believe peer reviews are very valuable. They help to build trust and respect between colleagues and are a natural way of encouraging knowledge sharing. They also serve as a very good way of normalising regular candid feedback. This post is not meant as a rant about everything that people do wrong. It is meant to give a strong foundation for people that have not done code reviews before. It is meant to make people that do code reviews think and discuss their approaches. Finally, it is meant as a reminder to myself that taking the time needed for a proper code review is important. Thanks for reading until the end and I hope it helps.\n","data":{"categories":"Software development;Teamwork","date":"2022-02-02","description":"Things to do before starting a code review, best practises on how to do a code review, and things to be mindful of. What to check before submitting your code review. How to avoid long discussions and conflict when doing peer review.","imageUrl":"https://images.unsplash.com/photo-1454165804606-c3d57bc86b40?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80","title":"How to code review"},"isEmpty":false,"excerpt":""},{"id":"react-conditional-rendering","subheadings":["TL;DR","Introduction","Multiple conditions","Intrinsic cognitive load","The hidden cost of software requirements","Don't repeat yourself","Error reporting, debugging, and testing","Conclusion"],"content":"\n# Clean-er ReactJS Code - Conditional Rendering\n\n![A lot of spaghetti](https://images.unsplash.com/photo-1559394452-087c19c260ac?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1176&q=80)\n\n## TL;DR\n\nMove render conditions into appropriately named variables and abstract the condition logic into a function. This makes the render function code a lot easier to understand, refactor, reuse and test.\n\n## Introduction\n\nConditional rendering is when a logical operator determines what will be rendered. The following code is taken from examples given in the official ReactJS documentation. It is one of the simplest examples of conditional rendering that I can think of.\n\n```javascript\nfunction Mailbox(props) {\n  const unreadMessages = props.unreadMessages;\n  return (\n    <div>\n      <h1>Hello!</h1>\n      {unreadMessages.length > 0 && (\n        <h2>You have {unreadMessages.length} unread messages.</h2>\n      )}\n    </div>\n  );\n}\n\nconst messages = [\"React\", \"Re: React\", \"Re:Re: React\"];\nReactDOM.render(\n  <Mailbox unreadMessages={messages} />,\n  document.getElementById(\"root\")\n);\n```\n\nIf you ask me, it would be better to write this as a function outside the scope of the Component. This would improve both code readability and code reusability, making the code easier to test and optimise. Above all, this would lessen the cognitive load experienced by programmers.\n\n## Multiple conditions\n\nThis is an example of conditional rendering that I come across quite often. Instead of a single condition, we now have many conditions inside the render function.\n\n```javascript\nconst OptionsPanel = ({ user }) => {\n  const { role } = user;\n\n  return (\n    <>\n      {role !== 29 && role !== 21 && role !== 11 && role !== 30 ? (\n        <div>Admin options panel placeholder</div>\n      ) : (\n        <div>User options panel placeholder</div>\n      )}\n    </>\n  );\n};\n\nReactDOM.render(\n  <OptionsPanel user={{ role: 5 }} />,\n  document.getElementById(\"root\")\n);\n```\n\nIf the user role is 29, 21, 11 or 30, we return the AdminOptionsPanel Component. If the user role is anything else, we return the UserOptionsPanel. These are the main issues I have with this approach:\n\n- The business logic is paired with the render logic. This makes it harder to think about the render logic in isolation.\n- The business logic is not communicated at all. Without knowing what roles 29, 21, 11, and 30 stand for, the reader does not know why this decision has been made.\n- The condition is not exportable. If we have the same render condition for different elements inside our codebase, we will have to repeat it.\n- The condition is hard to test in isolation. Render functions are seldom this simple. Testing the final output of the Component will not determine if the render condition is causing issues.\n\n## Intrinsic cognitive load\n\nThis is the inherent level of difficulty associated with a specific instructional topic. The more complex the instructions, the more mental effort is required to understand them. 4 + 9, for example, is easier to understand and make sense of than a complex mathematical equation. In our code example, we are mixing two different types of information at the same time, relying on the reader to know what certain roles mean. Without that, they are unable to know the intent behind our Component. Let's refactor the code to address this first.\n\n```javascript\nconst OptionsPanel = ({ user }) => {\n  const { role } = user;\n\n  const displayAdminOptionsPanel = React.useMemo(\n    () => role !== 29 && role !== 21 && role !== 11 && role !== 30,\n    [role]\n  );\n\n  return (\n    <>\n      {displayAdminOptionsPanel ? (\n        <div>Admin options panel</div>\n      ) : (\n        <div>User options panel</div>\n      )}\n    </>\n  );\n};\n```\n\nIt may not seem like much, but now we have split our logic into two thought processes, and can consider one without thinking about the other. When checking if the render function works, it’s important that we check the ternary condition and markup.\n\nLikewise for the `displayAdminOptionsPanel` constant - we need to concern ourselves with how the content of the variable (true/false in our case) is set. The intrinsic cognitive load of the person trying to understand our code is consequently a lot smaller. As a nice bonus, we are also able to wrap our variable inside the ReactJS `useMemo` hook.\n\nI know, I know… I can already hear you grumbling about my pointless nitpicking. After all, the effort that goes into this would be better spent writing more code, right? The thing is that decisions like these do matter. They will impact your performance in invisible ways, and sooner or later, the camel’s back will give way. We read a large amount of functions like these every day, so the intrinsic cognitive load is important. The time we spend trying to understand code that’s already written could be better spent writing new code.\n\n## The hidden cost of software requirements\n\nDevelopers are almost never lucky enough to get very specific instructions. Our customers don’t simply say \"user role 22 should have access to the admin options panel\". Instead, the bug report or feature request is phrased from their perspective - that of the business. We often get feedback like \"Project managers should also be able to access the admin options\". Or rather, \"Joe from project management cannot access the options\". It’s our job to know that Joe from project management has user role 22, and decipher where the issue in the code is coming from. With this in mind, let's try to refactor our previous code to make the business logic clearer.\n\n```javascript\nconst ALL_USER_ROLES = [\n  29, // admin\n  21, // sales\n  11, // project management\n  30, // marketing\n  5, // customer\n  10, // intern\n];\n\nconst ADMIN_ROLES = [29, 21, 11, 30];\n\nconst hasAdminPermissions = (userRole) => ADMIN_ROLES.includes(userRole);\n\nconst OptionsPanel = ({ user }) => {\n  const { role } = user;\n\n  const displayAdminOptionsPanel = React.useMemo(\n    () => hasAdminPermissions(role)[(hasAdminPermissions, role)]\n  );\n\n  return (\n    <>\n      {displayAdminOptionsPanel ? (\n        <div>Admin options panel</div>\n      ) : (\n        <div>User options panel</div>\n      )}\n    </>\n  );\n};\n```\n\nWe have documented every known user role and admin role in our system. We have abstracted the check to see if a user has admin permissions into a separate function, further reducing the intrinsic cognitive load of our reader. It is now clear what the initial software requirements were; the admin options panel should only be available for users with admin permissions. We can now check our four points of failure in isolation:\n\n- Are the roles correctly defined?\n- Is the function that checks the user roles working as expected?\n- Is the component passing the user role to the function?\n- Is the render ternary condition correct?\n\nThe reader no longer has to know why only users with certain roles are able to access the admin options panel. The code provides this information, simplifying communication between coworkers by making questions more specific. It also makes certain questions (why-does-the-code-work-this-way types of questions) redundant.\n\n## Don't repeat yourself\n\nThere is another benefit to moving the business logic into a separate function - business logic is often repeated. If we follow our example, users with admin permissions might be able to see other parts of the interface. They might be able to access certain confidential data or edit particular information. In that case, having a reusable function for checking user role permissions is very handy. It provides a single point of failure and debugging for the whole codebase. Once we validate that it works as specified, it will work that way everywhere. We no longer have to do a global search for this condition to add an admin role or remove an existing one. These are all great benefits that improve productivity and confidence in our codebase.\n\n## Error reporting, debugging, and testing\n\nStructuring our code this way allows for better error reporting. We now see which specific function failed and can fix it in isolation. Moreover, debugging our code is easier since we can focus on a much smaller scope at a time. Finally, testing our code can be a lot more specific. While before we could only test what our component rendered, we can now check every single step:\n\n- Did the roles come from the correct constant?\n- Did the function check the user role permissions?\n- Did the Component call the permissions check, passing the right argument?\n- Did the render return the correct markup?\n\nThis gives us a lot more confidence when refactoring or adding more functionalities.\n\n## Conclusion\n\nWriting logic unrelated to markup in separate functions has a lot of added benefits:\n\n- It reduces cognitive load, enabling us to do more.\n- Business logic is separated and easier to understand.\n- Our code is reusable and provides a single source of truth.\n- Error reporting is more specific.\n- Testing is more specific and gives faster and better feedback.\n\nAll this results in greater ease when it comes to bug fixing, refactoring and adding features. That being said, this is not a silver bullet that will work in all cases. Sometimes structuring your code in this way is more effort than it’s worth. After reading this post, you can now decide for yourself whether the benefits for your team outweigh the effort this approach requires.\n","data":{"categories":"ReactJS;Clean Code","date":"2022-01-07","description":"How to write clean, extendable, and testable render functions for ReactJS components.","imageUrl":"https://images.unsplash.com/photo-1559394452-087c19c260ac?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1176&q=80","title":"Clean-er ReactJS Code - Conditional Rendering"},"isEmpty":false,"excerpt":""}]