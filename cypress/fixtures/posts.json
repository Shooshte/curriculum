[{"id":"I-know-how-to-code-now-what","headings":[{"text":"TL;DR","chapters":[]},{"text":"The current job market","chapters":[]},{"text":"Producing consistent results","chapters":[{"text":"Double your estimated time","chapters":[]},{"text":"Write automated tests for the code you are working on.","chapters":[]},{"text":"Stick to the plan","chapters":[]},{"text":"Work with the people around you","chapters":[]}]},{"text":"Building a team, and working in one","chapters":[{"text":"Building trust","chapters":[]},{"text":"Establishing common goals","chapters":[]},{"text":"Show your teammates that you value their opinion","chapters":[]}]},{"text":"Sharing Knowledge","chapters":[]},{"text":"Git gud","chapters":[]}],"content":"\n![Open road in an autumn forest](https://images.unsplash.com/photo-1476820865390-c52aeebb9891?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80)\n\n# I know how to code…now what?\n\n## TL;DR\n\n- Producing consistent results.\n- Learning how to build (and work in) a team.\n- Communicating effectively.\n- Presenting convincing results.\n- Knowledge Sharing.\n\n## The current job market\n\n![A lot of money notes](https://images.unsplash.com/photo-1621378864046-0122e4a415a5?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80)\n\nThere is a very big discrepancy between the salaries offered in mid-level and senior level software developer roles. Even though the job ads look for employees that know the same technology and would work on completing equally complicated tasks, the yearly wage difference can be more than $100,000! Part of this can be attributed to the job market going global. Nowadays, everyone can apply for remote jobs and work for companies in countries with the richest economies. It will take some more time for the job market to adjust accordingly and hopefully level itself out. Nevertheless, one of the principal reasons for this discrepancy is the possession of additional non-technical skills that make certain senior developers worth a lot more than others.\n\nWhile there are a lot of resources online focusing on how to get really (and I mean REALLY) good at writing code, there seems to be a lack of reading material focusing on these additional skills. This post can be seen as a starting point - a way of assessing where you currently stand - and acts as a foundation on which to base your googling.\n\n## Producing consistent results\n\n![Different robot toys](https://images.unsplash.com/photo-1582571352032-448f7928eca3?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1292&q=80)\n\nOver-promising and under-delivering is a constant in software development. Coding is a creative process, and as in a lot of other creative fields, the performance of coders will vary from time to time. There are good days where everything just aligns perfectly and you can fly through your to-do list; and then there are days when even the easiest task takes a lot longer than it should. Adjusting deadlines according to this performance variance, as well as focusing on always ensuring the same quality of results, will instantly make you more valuable! Managers value consistency over anything else. Being able to rely on getting results saves a lot of headaches since being able to plan ahead and commit to a plan is key to running most successful businesses. To sum up, learn how to maintain the same level of quality and performance in all of the tasks that are asked of you.\n\nIf you want to become more consistent in your work, here are a couple of things to consider that helped me improve significantly:\n\n### Double your estimated time\n\nAt first, this sounds like a cynical joke, but it is the best thing you can do for your consistency, your mental health, and in effect, your colleagues! Having the extra time will save you when minor unforeseen adjustments need to be made. If everything goes according to plan, having the extra time to refactor, clean the code and write tests will ensure greater quality when it comes to your work. If you have extra time after you are done, use it to improve your skills, help your teammates or reduce technical debt you have in your codebase (there is always technical debt in any codebase). And if you really have nothing else to do for the remainder of the day, then you can let your manager know that you finished the task early.\n\n### Write automated tests for the code you are working on.\n\nThis one is so simple that I still cannot believe it took me more than 6 years to finally start doing it. If you are writing new code, write an end-to-end (integration) test that covers the functionality you are required to add. If you are modifying existing code, write an end-to-end test that covers the functionality already in the system before making changes to the code. Afterwards, add end-to-end tests for the functionality you are adding. This will ensure that you do not create any retention bugs and that the software you produce works as intended. It also has the added benefit of catching mistakes in the system that are not caused by your code. Fewer mistakes while manually testing means more consistency in the long run.\n\n### Stick to the plan\n\nClearly define the scope of the changes that you are making, and hold on to them for dear life. Focus on one thing at a time and do that one thing well. It is easy (trust me, I know) to get distracted and end up making “minor” improvements to the software while working on your task. While these may seem innocent, they take up a lot of your time and energy, and add more complexities that you need to test. Introducing potential points of failure is never a good thing when you are trying to be consistent, and changing the scope of what you are working on in the middle of implementation will also change the timeline.\n\n### Work with the people around you\n\nWork with your colleagues whenever possible. Pair-programming, code reviews and whiteboard planning are all very good ways to level out the good and the bad days. To put it simply, if I have one very good day per week, three average ones, and one bad one, I will benefit significantly from working with someone who is having a good day while I’m experiencing my bad one. Additionally, this is a great way to cover your weaknesses and use the strengths that are specific to you. While not everyone will have time to work with you, make this a part of your working process and do it as often as possible. When you feel like you are stuck or that no good ideas are popping up, it should feel natural to go to your colleagues and ask for their opinion. Even talking things over for just a couple of minutes might be the difference between working on a mediocre idea that reduces the quality of your work, or establishing a great one!\n\n## Building a team, and working in one\n\n![Different hands fist bumping over a work table](https://images.unsplash.com/photo-1583321500900-82807e458f3c?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80)\n\nThere is something inherently cool and romantic about the image of a lone coder creating something wonderful that everyone admires alone in the middle of the night. While there are some cases of this (Vampire Survivors being the latest), exceptional software is most commonly written by high-performing teams in which a lot of brilliant people work together. Learning how to work in a team and building a team with your colleagues is essential to being successful.\n\nThese are the things that are commonly missing, leading to a dysfunctional team: trust inside the team, a common goal, and a healthy debate before major decisions. Getting these right makes solving all other problems a lot easier. If you learn how to be a good teammate and contribute a lot to building a team, you will be worth a lot more to your manager. Saving them the headache of having to manage the relationship between you and your teammates is a sure fire way to improve your worth, especially in a field where good people skills are hard to find.\n\n### Building trust\n\nTalk openly about your weaknesses and strengths. Working in a team requires trust, and the best way to establish this is by talking openly about the things you might be lacking. When you ask people for help - either with doing specific tasks or as a way of improving your skills - they will trust you more. Discussing the things you are good at, meanwhile, will enable people to ask you for help with your area of expertise. A combination of being vulnerable and also enabling others is very good for building trust within a team.\n\nFurthermore, aim to talk transparently about your mistakes. Nothing breaks trust more than sweeping your mistakes under the rug and pretending they never happened. Put your mistakes in the limelight so that you and the whole team can benefit by learning from them! This will also show your teammates that you do not have a hidden agenda or a personal goal, but rather that you made an honest mistake and want to fix the situation, improve your work, and avoid repeating the same error in future.\n\n### Establishing common goals\n\nEstablishing a common goal is very important so as to be able to resolve conflict and tension within the team. When what the team wants to achieve is agreed upon and clear, people are much more receptive to constructive feedback, show more focus, and don’t engage as much in company politics. This establishes a clear reference for when decisions need to be made - you can always evaluate whether a decision will bring the team closer to one of the goals.\n\nHaving a clear goal that everyone is working towards is also a great motivator for you and your teammates. It will enable everyone to work independently, be more creative, and take ownership of big decisions. This results in more satisfaction and productivity amongst employees. Context matters a lot! Imagine a difference between a factory worker producing ammunition without knowing what it will be used for and a factory worker producing ammunition that will be used to fight an invading nation. Being able to envision a goal clearly also brings the benefit of pushing everyone through the tasks that are not pleasant or exciting.\n\n### Show your teammates that you value their opinion\n\nLet everyone speak their minds before a decision is made, even if you believe (or know) they are wrong. Wanting to achieve a consensus on decisions is highly overrated. We often fall into the trap of trying to convince everyone to agree with us so much that we do not let them state their opinion. In reality, people are usually okay with the decision to not do things their way, so long as they get to express their opinion or argue for it. So let everyone that wants to make their points speak and then decide on a plan of action. After that, make sure that everyone inside the team knows what the next course of action is, and how it will help to achieve the team's goal. Create the space for your teammates to speak, and listen carefully to what they have to say. Even if you do not agree with them in the end, showing your teammates that you value their opinion is very beneficial, and will bring you closer together!\n\n## Sharing Knowledge\n\n![Books](https://images.unsplash.com/photo-1457369804613-52c61a468e7d?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80)\n\nTeaching what you know is a great way to empower people around you. When you are explaining what you know to somebody else, you are forced to fill up the holes in your own knowledge. It is a great way to gain trust and positive or constructive feedback from your coworkers. When you are able to raise the performance of your teammates, you are adding a lot more than just your coding output to the team, making you very valuable! While knowledge sharing is a complex topic, I find doing these simple things is a great way of getting the communication started:\n\n- Pair programming\n- Code reviews\n- A scheduled weekly 15-30 min codebase state review\n- Development of sprint retrospectives\n- “Water cooler” conversations\n\nFind a way to actively engage with your coworkers when you do this, and set some clear motivation as to why they should discuss a certain topic with you. Being able to work faster or solving a specific problem they recently encountered are good examples of that. Don’t just link a tweet, a blog post, or a book title and expect people to do the rest on their own. Even if they follow up on the reading material you provide, this will not point back to you. Instead you want your manager to hear “I learn a lot from him” when they ask your peers for an opinion.\n\n## Git gud\n\nAll of the above will help you when negotiating your salary as they will increase your value a lot compared to other candidates that only know how to code. That being said, you still need to know how to code, and know how to do it well. This post is about supporting skills, and none of these matter if the code you are writing is structured poorly, does not work, or pisses off your colleagues. Git gud, and good luck on your journey!\n","data":{"categories":"Software development;","date":"2022-05-05","description":"How to get paid more for writing code? How to advance my career in software development? What do employers value in developers? What makes a senior developer? How to get paid at the top of the coding market? How to work in a team?","imageUrl":"https://images.unsplash.com/photo-1476820865390-c52aeebb9891?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80","imageDescription":"Open road in an autumn forest","title":"I know how to code…now what?"},"isEmpty":false,"excerpt":""},{"id":"automatically-testing-web-applications","headings":[{"text":"TL;DR","chapters":[]},{"text":"Grunt work","chapters":[]},{"text":"Different types of automated tests","chapters":[{"text":"Unit testing","chapters":[]},{"text":"Integration testing","chapters":[]},{"text":"End-to-end testing","chapters":[]}]},{"text":"How to approach testing software","chapters":[]},{"text":"Context matters","chapters":[]}],"content":"\n![An old man in a workshop](https://images.unsplash.com/photo-1607969891751-1374d59ab4fa?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80)\n\n# Automatically testing web applications\n\n## TL;DR\n\n- Automate tests that need to be repeated with every deploy\n- Focus on end-to-end testing for business critical user scenarios\n- Apply the same standards and coding practices for test code and feature code\n- Make failing end-to-end tests block publishing your application, that needs to be overridden manually\n\n## Grunt work\n\nPeople are bad at focusing on repeating the same task, and little gets older quicker than testing an application. What starts as a fun and exciting process of seeing the code you wrote run for the first time soon becomes automatic clicking while your brain zones out. This leads to all kinds of obvious errors and mistakes, missing functionality that angers your coworkers and (god forbid) customers.\n\nThe problem is not specific to software. It happens in every process where a repeated task is done by humans. Japanese underground workers have taken to combating it by implementing a point and say technique. They stay alert by pointing at the thing they are supposed to verify and state that everything is OK out loud. While seeing a person pointing at the safety line on the train station and yelling “All clear!” out loud might be comical, it also has the added benefit of reducing the accident rate by more than 50 percent when done by the whole team.\n\nAutomatic software testing applies the same principle. A computer runs the software, points at one part of the process and yells out whether everything is OK or not. While most developers know this is good in theory, it can still be overwhelming to do it in practice. This post focuses on providing an overview of essentials, while still staying very theoretical. In case you want to google a get-started blog post after finishing this article, my favourite test runner for front-end applications in 2022 is Cypress.js.\n\n## Different types of automated tests\n\nBefore talking about my approach to testing web applications, I want to briefly talk about different testing approaches. These can be separated into the three categories listed below.\n\n### Unit testing\n\nUnit testing is a testing technique concerned with functional correctness of the standalone modules. The main aim is to isolate each unit of the system to identify, analyse and fix the defects. The units tested can be small functions, individual classes, or modules. Unit tests are very useful when refactoring and debugging, but will not cover everything. Even if all parts of a system work as expected in isolation, the whole might still malfunction.\nIn my opinion, unit tests are strictly a software development tool and should be treated as such. If unit testing makes your team more reliable and the work faster, use it, if not, you can skip this part of tests. They should never replace manual testing or QA.\n\n### Integration testing\n\nIntegration testing is done on groups of modules to make sure they work together and interact properly. Most projects are big enough that development is broken down into several smaller modules, and integration testing ensures that different modules can work with each other.\n\nThese types of tests are particularly useful when your software is dependent on modules you do not control. As an example, a third-party authentication provider (such as Facebook or Google) might publish a new update that breaks your integration, locking all users out of the application. While integration tests will show you the general health of your system, they fall in the same category as unit tests. They are a development tool, used to make refactoring and fixing malfunctions easier.\n\n### End-to-end testing\n\nEnd-to-end testing is a technique for testing the entire software product from the beginning to end in order to ensure that the application flow behaves as expected from the beginning to end. The main purpose is to test the end user’s experience by simulating the real user scenario. These types of tests are useful to ensure that your application users are able to use the software without encountering anything unexpected.\n\n## How to approach testing software\n\n![push button wait for walk signal traffic light](https://images.unsplash.com/photo-1464037788451-47f64cfda692?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80)\n\nI believe that writing end-to-end tests when writing software is essential to maintaining a good user experience. Our web applications change over time, and having an automatic test for features we are supporting speeds up the development process considerably. While end-to-end tests will not ensure quality, they will ensure that our users are at least able to interact with our UI and get the desired results.\n\nAfter we have end-to-end tests set up, we can evaluate whether integration and/or unit tests could be beneficial as well. This will largely depend on the implementation of the feature. If the code we wrote is integrating a lot of external modules, we might want integration tests to ensure that changes to those modules do not break our app. If the code we wrote is used in multiple places over our application we might want to write unit tests in order to ensure that it has the expected results even if it changes later on.\n\nSo what does a healthy step-by-step implementation of automated tests for a web application feature look like in my opinion?\n\n1. Define the goal of the feature from the user's perspective.\n2. Implement the feature.\n3. Test the feature manually.\n4. Write an end-to-end test that repeats the manual test.\n5. Decide if integration tests would be beneficial.\n6. Decide if unit tests would be beneficial.\n\nLet us put this list into practice in a real-life scenario that I recently came across. This suite of automated tests ensure that a cookies consent banner decline button works as expected.\n\n1. When a user that did not accept or decline cookies before visits the web page a cookies consent banner including the appropriate heading, explanation and buttons should be shown. The banner should have screen-reader friendly markup. When the decline button is clicked the cookies consent banner should disappear. Afterwards no cookies should be stored. After reloading the page the cookies banner should not be shown, and no cookies should be stored.\n2. I implemented this feature using a ReactJs Component that adds additional script elements to the DOM when consent is given, which in turn save cookies needed to run google analytics.\n3. I tested the feature manually, reading the content of the banner and running a screen reader. I validated that when I clicked decline no cookies were stored. I reloaded the page, checked that the banner is not shown and that no cookies were stored.\n4. I wrote a Cypress.js test that repeats this process. These are the steps that the test function executes:\n   1. Navigates to a website URL.\n   2. Validate that the cookies consent banner markup is present in the DOM.\n   3. Validate that no cookies are stored inside the browser.\n   4. Click the decline button inside the cookies consent banner.\n   5. Validate that no cookies are stored inside the browser again.\n   6. Reload the current page.\n   7. Validate that the cookies consent banner markup is not present in the DOM.\n   8. Validate that no cookies are stored inside the browser.\n5. I created a list of all of my web applications URLs that need to show the cookies consent banner on load and added running the test function for every one of these.\n6. I added an integration test that checks if the google analytics script that handles storing cookies is added to the DOM and loaded inside the browser when decline is clicked. Not loading the script means that the integration is correct - loading additional resources that the user declined is bad.\n7. I added a simple unit test for part of the functionality. During the implementation I wrote a function that stores values into localstorage which I plan on using in other parts of the application.\n\nThis is a stark contrast to test-driven-development that would start by writing the test first, before implementing the feature. I find that this is a much more pragmatic approach, since software is very rarely fully defined before implementation. Creating an MVP, writing an end-to-end test for it, getting feedback and then iterating while checking that everything still works as expected is a flow that works a lot better for me.\n\n## Context matters\n\n![Green umbrella between forest trees](https://images.unsplash.com/photo-1591691203197-c00ee071407a?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1181&q=80)\n\nThe approach described above is what I consider a healthy, pragmatic approach to writing software. However, you should always consider the context that you are working in. These are a few examples of when an approach like this is not the best fit:\n\n- Writing experimental features that are not vital to the core business.\n- Writing features for which the market is not yet validated.\n- Business is not impacted by reliability. While rare, there are cases when being the first to market is a lot more important than having a product that works well.\n- The software will not be further maintained or developed.\n\nThese examples are meant to illustrate that as always, there is no silver bullet, and no best-practice that fits all situations. Software development is a complicated field that needs to take a lot of different factors into account. You should always try to change your work process according to the needs of the specific project. That being said, I believe that most projects would significantly benefit from the approach described above.\n","data":{"categories":"Software development;Testing","date":"2022-04-02","description":"Is it a waste of time to carry out automatic testing on web applications? What is the best way to approach web application testing, and what are the most common mistakes when doing it? Should I write automated UI tests?","imageUrl":"https://images.unsplash.com/photo-1607969891751-1374d59ab4fa?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1171&q=80","imageDescription":"An old man in a workshop","title":"Automatically testing web applications"},"isEmpty":false,"excerpt":""},{"id":"how-to-code-review","headings":[{"text":"TL;DR","chapters":[]},{"text":"Introduction","chapters":[]},{"text":"Check that the code can be built and deployed","chapters":[]},{"text":"Scope and intent","chapters":[]},{"text":"Make sure the code fulfills the intent","chapters":[]},{"text":"Ensure all comments relate to the main points of focus.","chapters":[]},{"text":"Spellcheck your comments and remove unnecessary information.","chapters":[]},{"text":"Have discussions in person or over a call, and only write down the summary","chapters":[]},{"text":"Let the author know if they can merge the code","chapters":[]},{"text":"Conclusion","chapters":[]}],"content":"\n![A person taking notes on a piece of paper between two laptop screens](https://images.unsplash.com/photo-1454165804606-c3d57bc86b40?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80)\n\n# How to code review\n\n## TL;DR\n\nI'm a developer, so of course I wrote a checklist:\n\n- Check that the code can be built and deployed.\n- Define the scope and intent of the code you are reviewing.\n- Check that the code fulfils the intent\n- Ensure all comments and discussions are related to maintainability, performance, or functionality.\n- Spell check your comments and remove any unnecessary information.\n- Have discussions in person or over a call, and only write down the summary\n- Let the author know if they can merge the code.\n\n## Introduction\n\nAll companies and organisations that I’ve worked for recognise the value of peer reviews. They praise it in company-wide all-hands meetings. They make it an obligatory part of the software development process. They encourage everyone to give candid feedback as often as possible.\n\nAnd yet, none of them have added peer review training to their onboarding process. None of the interviews I’ve had have included specific questions about code reviews. None of these companies have provided guidelines on what separates a good, useful code review from a bad one. Their managers and team leaders do not lead by example. They do not set the norm by defining a context of what is and what is not allowed.\n\nAll have employees that oppose (sometimes very vocally) doing code reviews. All have employees that see code reviews as something imposed on them - something that they would rather not do, and something that they can do half-heartedly. There is a clear divide between an abstract concept we all know is good and the process of actually putting it into practice.\n\nThis post focuses on being pragmatic; what to do, what not to do, and how to get the biggest benefit from peer reviews. The points I make can serve as a foundation for putting code reviews into practice, and can serve as a base for comparison of how well your team is currently doing. They are not a be-all-end-all solution. When working in a team, we should adjust to the team’s specific needs and personalities, and be mindful of the context of our specific situation. Nevertheless, this is a good place to start and improve upon.\n\n## Check that the code can be built and deployed\n\nMost projects have an automated process in place for doing this. In the JavaScript world, CI linting, tests and builds are common. That being said, some projects might not have these fail-safes. The fail-safe might fail, they might not block the merge request from opening, or the author might have missed the automatic message about a failing build.\n\nAlways check if the code can be built and deployed as is. If the build or another part of the deployment process fails, there is no point in doing a review. The code will need to be changed and reviewed again before being merged.\n\n## Scope and intent\n\nBefore reading the code, you should define the scope and intent of the proposed changes. This was already done by the colleague writing the code before you, but it most likely needs a revision. They might not have documented it, they might have missed an important detail, or they might even have misinterpreted what the code should do. Without understanding the scope and intent, you do not have a yardstick against which to measure the code.\n\nIf you’re having trouble doing this, here are some good questions to ask. You can try to answer these yourself, but after you do, always check that the author of the code agrees with you.\n\n- What should change for the user of the software?\n- What should change for the person making the software?\n- How much value does this change bring to the company?\n\nThese questions should help to define how important the three main points of focus for the code review - maintainability, performance, and functionality - are. It might bring another point of focus, and it might even mean that one of the main points is irrelevant. People don't value maintainability and performance when a production bug is costing the company large amounts of money. People value maintainability when adding new core features to the system. Think about considerations like these before starting to review the work.\n\n## Make sure the code fulfills the intent\n\nThis is what I see skipped the most when developers are tired or in a hurry. Surely the person that wrote the code checked what it does? Trust me, there is no feeling more stupid than not running the code and approving it, only to deploy a bug. You get frustrated with the author of the code. They should’ve done better. The author gets frustrated with you. You were supposed to be the fail-safe they could depend on.\n\nAs with the build and deploy step, commenting on the code that does not fulfil its intent is irrelevant. The code will need to be changed and reviewed again afterwards. Check if everything works as expected, and if not, let the author know what is wrong without looking at the code.\n\n## Ensure all comments relate to the main points of focus.\n\nSo we’ve finally got to the part where you get to read the code. When reviewing the code, keep the main points of the review in mind. How important is the maintainability of the code? How important is the functionality? How important is the performance? Is there anything else that is equally important, or perhaps even more so? Always try to communicate to the reader what your comments and suggestions relate to. Constructive criticism is received much better when it means achieving a common goal.\n\nAfter you are finished reading and commenting on the code, review your comments. Pause if you need to refresh for a bit. Try to read the comments from the perspective of the person receiving the feedback. Is it easy to understand what you are trying to say? Are the comments relevant? Are they concise and to the point? Can they be perceived as overly emotional or critical? Is there any information missing? Is all the information in the comment relevant?\n\n## Spellcheck your comments and remove unnecessary information.\n\nLet me start by quoting a popular Twitch streamer that I enjoy watching. \"If you are not able to right-click the squiggly word and choose the correct spelling, you are not very smart. Why would I value your opinion?\". You should ensure that all your comments are spelled and worded correctly. You should check that all the information in the comment is relevant. If something is not relevant to the point you are making, remove it from the comment.\n\nThis shows your colleagues that you value their time. Everybody hates getting back a code review that is blocking a merge. Don't waste your colleagues’ time by making them guess which word you misspelled. Don't make your colleagues read additional information that they do not need to know.\n\n## Have discussions in person or over a call, and only write down the summary\n\nt is not uncommon for a comment or suggestion to reveal a lack of understanding. People will often disagree with your opinion. They will want a chance to explain their decisions. These discussions can become long and dragged out, and sometimes reaching a decision can take days. Written text is also subject to different emotional interpretations - you do not get any real-time feedback as to whether the person you are talking to understands you, and you cannot return such feedback either.\n\nI find that in cases in which a discussion is needed, this is usually best done in person or through a video call. It speeds up the process considerably, allowing everyone to be on the same page. It gives everyone a chance to be able to stop the other person and say, \"Stop, I don't understand what you mean. Please elaborate a bit”. After the discussion, a summary needs to be written under the code review comment. It should document which decision was made and why. More than one person might review the code, or you might want to come back to the code after a while and check why something was added. The explanation should be plain to see.\n\n## Let the author know if they can merge the code\n\nAfter you are satisfied with your comments, you should let the author know if they can merge the code or not. This is the only part of the code review that I feel the team (or the company) should have clear guidelines for. The person that requested the code review should know if the code can be deployed or not. While this might seem obvious when written down, a lot of edge cases happen when things are not clear. It will occur that a suggestion or comment will be good but out of scope. In that case, after it is written down for further improvements, the code can be merged. It is also likely that you will want to point out a bad practice that harms maintainability, or something that affects code performance. Some of these comments will not be implemented, but they nonetheless have learning value. It should be clear after the review which comments (if any) need to be addressed before merging the code.\n\n## Conclusion\n\nI believe peer reviews are very valuable. They help to build trust and respect between colleagues and are a natural way of encouraging knowledge sharing. They also serve as a very good way of normalising regular candid feedback. This post is not meant as a rant about everything that people do wrong. It is meant to give a strong foundation for people that have not done code reviews before. It is meant to make people that do code reviews think and discuss their approaches. Finally, it is meant as a reminder to myself that taking the time needed for a proper code review is important. I hope it helps.\n","data":{"categories":"Software development;Teamwork","date":"2022-02-02","description":"Things to do before starting a code review, best practises on how to do a code review, and things to be mindful of. What to check before submitting your code review. How to avoid long discussions and conflict when doing peer review.","imageUrl":"https://images.unsplash.com/photo-1454165804606-c3d57bc86b40?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80","imageDescription":"A person taking notes on a piece of paper between two laptop screens","title":"How to code review"},"isEmpty":false,"excerpt":""},{"id":"react-conditional-rendering","headings":[{"text":"TL;DR","chapters":[]},{"text":"Introduction","chapters":[]},{"text":"Multiple conditions","chapters":[]},{"text":"Intrinsic cognitive load","chapters":[]},{"text":"The hidden cost of software requirements","chapters":[]},{"text":"Don't repeat yourself","chapters":[]},{"text":"Error reporting, debugging, and testing","chapters":[]},{"text":"Conclusion","chapters":[]}],"content":"\n![HTML code on a computer screen](https://images.unsplash.com/photo-1542831371-29b0f74f9713?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80)\n\n# Clean-er ReactJS Code - Conditional Rendering\n\n## TL;DR\n\nMove render conditions into appropriately named variables and abstract the condition logic into a function. This makes the render function code a lot easier to understand, refactor, reuse and test.\n\n## Introduction\n\nConditional rendering is when a logical operator determines what will be rendered. The following code is taken from examples given in the official ReactJS documentation. It is one of the simplest examples of conditional rendering that I can think of.\n\n```javascript\nfunction Mailbox(props) {\n  const unreadMessages = props.unreadMessages;\n  return (\n    <div>\n      <h1>Hello!</h1>\n      {unreadMessages.length > 0 && (\n        <h2>You have {unreadMessages.length} unread messages.</h2>\n      )}\n    </div>\n  );\n}\n\nconst messages = [\"React\", \"Re: React\", \"Re:Re: React\"];\nReactDOM.render(\n  <Mailbox unreadMessages={messages} />,\n  document.getElementById(\"root\")\n);\n```\n\nIf you ask me, it would be better to write this as a function outside the scope of the Component. This would improve both code readability and code reusability, making the code easier to test and optimise. Above all, this would lessen the cognitive load experienced by programmers.\n\n## Multiple conditions\n\nThis is an example of conditional rendering that I come across quite often. Instead of a single condition, we now have many conditions inside the render function.\n\n```javascript\nconst OptionsPanel = ({ user }) => {\n  const { role } = user;\n\n  return (\n    <>\n      {role !== 29 && role !== 21 && role !== 11 && role !== 30 ? (\n        <div>Admin options panel placeholder</div>\n      ) : (\n        <div>User options panel placeholder</div>\n      )}\n    </>\n  );\n};\n\nReactDOM.render(\n  <OptionsPanel user={{ role: 5 }} />,\n  document.getElementById(\"root\")\n);\n```\n\nIf the user role is 29, 21, 11 or 30, we return the AdminOptionsPanel Component. If the user role is anything else, we return the UserOptionsPanel. These are the main issues I have with this approach:\n\n- The business logic is paired with the render logic. This makes it harder to think about the render logic in isolation.\n- The business logic is not communicated at all. Without knowing what roles 29, 21, 11, and 30 stand for, the reader does not know why this decision has been made.\n- The condition is not exportable. If we have the same render condition for different elements inside our codebase, we will have to repeat it.\n- The condition is hard to test in isolation. Render functions are seldom this simple. Testing the final output of the Component will not determine if the render condition is causing issues.\n\n## Intrinsic cognitive load\n\nThis is the inherent level of difficulty associated with a specific instructional topic. The more complex the instructions, the more mental effort is required to understand them. 4 + 9, for example, is easier to understand and make sense of than a complex mathematical equation. In our code example, we are mixing two different types of information at the same time, relying on the reader to know what certain roles mean. Without that, they are unable to know the intent behind our Component. Let's refactor the code to address this first.\n\n```javascript\nconst OptionsPanel = ({ user }) => {\n  const { role } = user;\n  const displayAdminOptionsPanel = React.useMemo(\n    () => role !== 29 && role !== 21 && role !== 11 && role !== 30,\n    [role]\n  );\n\n  return (\n    <>\n      {displayAdminOptionsPanel ? (\n        <div>Admin options panel</div>\n      ) : (\n        <div>User options panel</div>\n      )}\n    </>\n  );\n};\n```\n\nIt may not seem like much, but now we have split our logic into two thought processes, and can consider one without thinking about the other. When checking if the render function works, it’s important that we check the ternary condition and markup.\n\nLikewise for the `displayAdminOptionsPanel` constant - we need to concern ourselves with how the content of the variable (true/false in our case) is set. The intrinsic cognitive load of the person trying to understand our code is consequently a lot smaller. As a nice bonus, we are also able to wrap our variable inside the ReactJS `useMemo` hook.\n\nI know, I know… I can already hear you grumbling about my pointless nitpicking. After all, the effort that goes into this would be better spent writing more code, right? The thing is that decisions like these do matter. They will impact your performance in invisible ways, and sooner or later, the camel’s back will give way. We read a large amount of functions like these every day, so the intrinsic cognitive load is important. The time we spend trying to understand code that’s already written could be better spent writing new code.\n\n## The hidden cost of software requirements\n\nDevelopers are almost never lucky enough to get very specific instructions. Our customers don’t simply say \"user role 22 should have access to the admin options panel\". Instead, the bug report or feature request is phrased from their perspective - that of the business. We often get feedback like \"Project managers should also be able to access the admin options\". Or rather, \"Joe from project management cannot access the options\". It’s our job to know that Joe from project management has user role 22, and decipher where the issue in the code is coming from. With this in mind, let's try to refactor our previous code to make the business logic clearer.\n\n```javascript\nconst ALL_USER_ROLES = [\n  29, // admin\n  21, // sales\n  11, // project management\n  30, // marketing\n  5, // customer\n  10, // intern\n];\nconst ADMIN_ROLES = [29, 21, 11, 30];\n\nconst hasAdminPermissions = (userRole) => ADMIN_ROLES.includes(userRole);\n\nconst OptionsPanel = ({ user }) => {\n  const { role } = user;\n\n  const displayAdminOptionsPanel = React.useMemo(\n    () => hasAdminPermissions(role)[(hasAdminPermissions, role)]\n  );\n\n  return (\n    <>\n      {displayAdminOptionsPanel ? (\n        <div>Admin options panel</div>\n      ) : (\n        <div>User options panel</div>\n      )}\n    </>\n  );\n};\n```\n\nWe have documented every known user role and admin role in our system. We have abstracted the check to see if a user has admin permissions into a separate function, further reducing the intrinsic cognitive load of our reader. It is now clear what the initial software requirements were; the admin options panel should only be available for users with admin permissions. We can now check our four points of failure in isolation:\n\n- Are the roles correctly defined?\n- Is the function that checks the user roles working as expected?\n- Is the component passing the user role to the function?\n- Is the render ternary condition correct?\n\nThe reader no longer has to know why only users with certain roles are able to access the admin options panel. The code provides this information, simplifying communication between coworkers by making questions more specific. It also makes certain questions (why-does-the-code-work-this-way types of questions) redundant.\n\n## Don't repeat yourself\n\nThere is another benefit to moving the business logic into a separate function - business logic is often repeated. If we follow our example, users with admin permissions might be able to see other parts of the interface. They might be able to access certain confidential data or edit particular information. In that case, having a reusable function for checking user role permissions is very handy. It provides a single point of failure and debugging for the whole codebase. Once we validate that it works as specified, it will work that way everywhere. We no longer have to do a global search for this condition to add an admin role or remove an existing one. These are all great benefits that improve productivity and confidence in our codebase.\n\n## Error reporting, debugging, and testing\n\nStructuring our code this way allows for better error reporting. We now see which specific function failed and can fix it in isolation. Moreover, debugging our code is easier since we can focus on a much smaller scope at a time. Finally, testing our code can be a lot more specific. While before we could only test what our component rendered, we can now check every single step:\n\n- Did the roles come from the correct constant?\n- Did the function check the user role permissions?\n- Did the Component call the permissions check, passing the right argument?\n- Did the render return the correct markup?\n\nThis gives us a lot more confidence when refactoring or adding more functionalities.\n\n## Conclusion\n\nWriting logic unrelated to markup in separate functions has a lot of added benefits:\n\n- It reduces cognitive load, enabling us to do more.\n- Business logic is separated and easier to understand.\n- Our code is reusable and provides a single source of truth.\n- Error reporting is more specific.\n- Testing is more specific and gives faster and better feedback.\n\nAll this results in greater ease when it comes to bug fixing, refactoring and adding features. That being said, this is not a silver bullet that will work in all cases. Sometimes structuring your code in this way is more effort than it’s worth. After reading this post, you can now decide for yourself whether the benefits for your team outweigh the effort this approach requires.\n","data":{"categories":"ReactJS;Clean Code","date":"2022-01-07","description":"How to write clean, extendable, and testable render functions for ReactJS components.","imageUrl":"https://images.unsplash.com/photo-1542831371-29b0f74f9713?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80","imageDescription":"HTML code on a computer screen","title":"Clean-er ReactJS Code - Conditional Rendering"},"isEmpty":false,"excerpt":""}]